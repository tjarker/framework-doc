\chapter{Use Cases Code} %///////////////////////////////////////////////////////////////////////////////////////////////////////////
\section{GCD Test Code} %------------------------------------------------------------------------------------------------------

\begin{lstlisting}[language=scala, captionpos=b, caption=Test code for the GCD circuit.,label=lst:gcd_test]
import framework.*
import framework.given
import types.*
import Time.*

class GCD extends ModuleInterface("src/hdl/sv/GCD.sv") {

  val clock = ClockPort(10.ns)
  val reset = ResetPort()
  val req = Input(Bool())
  val ack = Output(Bool())
  val loadVal = Input(UInt(32.W))
  val result = Output(UInt(32.W))

  domain(clock, reset)(
    req,
    ack,
    loadVal,
    result
  )

  val a = Reg(32.W, "a")
  val b = Reg(32.W, "b")
  val state = Reg(3.W, "state")

}

class GcdBfm(gcd: GCD) {

  val states = Seq("wait_a", "ack_a", "wait_b", "compare", "update_a", "update_b", "ack_result")

  def printState()(using Sim, Async): Unit = {
    val s = summon[Sim]
    println(s"@${gcd.time}${"=" * 80}")
    println(s"State: ${states(s.peekReg(gcd.state).toInt)}")
    println(s"A = ${s.peekReg(gcd.a)} B = ${s.peekReg(gcd.b)}")
  }

  def transact(value: BigInt, expected: Option[BigInt])(using
      Sim,
      Async
  ): BigInt = {

    gcd.loadVal.poke(value)
    gcd.req.poke(true)

    gcd.clock.stepUntil(gcd.ack.peek)

    val res = gcd.result.peek
    expected.foreach { e =>
      gcd.result.expect(e)
    }

    gcd.req.poke(false)

    gcd.clock.stepUntil(!gcd.ack.peek)

    res
  }

  def calc(nums: (BigInt, BigInt))(using Sim, Async): BigInt = {
    transact(nums._1, None)
    transact(nums._2, Some(model(nums)))
  }

  def model(nums: (BigInt, BigInt)): BigInt = {
    nums._1.gcd(nums._2)
  }

  def reset()(using Sim, Async): Unit = {
    gcd.reset.assert()
    gcd.req.poke(false)
    gcd.loadVal.poke(0)
    gcd.clock.step()
    gcd.reset.deassert()
    gcd.clock.step()
  }

  def step(n: Int = 1)(using Sim, Async): Unit = {
    gcd.clock.step(n)

  }
}

@main def GcdSim(): Unit =
  Simulation(new GCD, 1.ns, Some("gcd.vcd")) { gcd =>
    val bfm = GcdBfm(gcd)

    fork {
      while (true) {
        bfm.printState()
        bfm.step()
      }
    }

    val tests = Seq(
      BigInt(12) -> BigInt(3),
      BigInt("6789AC", 16) -> BigInt("56789A", 16) 
    )
    bfm.reset()
    tests.foreach { test =>
      val res = bfm.calc(test)
      println(s"Result: ${res}")
    }
  }

\end{lstlisting}


\section{Clock Domain Crossing Test Code} %-----------------------------------------------------------------------------------

\begin{lstlisting}[language=scala, captionpos=b, caption=Test code for the clock domain crossing circuit.,label=lst:cdc_test]
import framework.*
import framework.given
import types.*
import Time.*

class CDC extends ModuleInterface("src/hdl/sv/CDC.sv") {

  val clk_l = ClockPort(6.ns)
  val clk_r = ClockPort(10.ns)

  val rst_l = ResetPort()
  val rst_r = ResetPort()

  val req_l = Input(Bool())
  val req_r = Output(Bool())

  val ack_l = Output(Bool())
  val ack_r = Input(Bool())

  val data_l = Input(UInt(32.W))
  val data_r = Output(UInt(32.W))

  domain(clk_l, rst_l)(
    req_l,
    data_l,
    ack_l
  )

  domain(clk_r, rst_r)(
    req_r,
    data_r,
    ack_r
  )

}

class HandshakeSender(
    clock: ClockPort,
    reset: ResetPort,
    req: Input[Bool],
    ack: Output[Bool],
    data: Input[UInt]
) {

  def reset()(using Sim, Async): Unit = {
    reset.assert()
    clock.step()
    reset.deassert()
  }

  def send(value: BigInt)(using Sim, Async): Unit = {
    req.poke(true)
    data.poke(value)
    clock.stepUntil(ack.peek)
    req.poke(false)
    data.poke(0)
    clock.stepUntil(!ack.peek)
  }
}

class HandshakeReceiver(
    clock: ClockPort,
    reset: ResetPort,
    req: Output[Bool],
    ack: Input[Bool],
    data: Output[UInt]
) {

  def reset()(using Sim, Async): Unit = {
    reset.assert()
    clock.step()
    reset.deassert()
  }

  def expect(value: BigInt)(using Sim, Async): Unit = {
    clock.stepUntil(req.peek)
    data.expect(value)
    ack.poke(true)
    clock.stepUntil(!req.peek)
    ack.poke(false)
  }
}

@main def CdcSim(): Unit =
  Simulation(CDC(), 1.ns, Some("cdc.vcd")) { cdc =>
    val magicNum = BigInt("deadbeef", 16)
    fork {
      val sender =
        HandshakeSender(cdc.clk_l, cdc.rst_l, cdc.req_l, cdc.ack_l, cdc.data_l)
      sender.reset()
      sender.send(magicNum)
    }.fork {
      val receiver = HandshakeReceiver(cdc.clk_r, cdc.rst_r, cdc.req_r, cdc.ack_r, cdc.data_r)
      receiver.reset()
      receiver.expect(magicNum)
    }.join()
  }
\end{lstlisting}  
