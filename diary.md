

=================================================================
Friday, 06.09.2024
-----------------------------------------------------------------

- one of the things which seem a bit strange about UVM could be
  the configurability approach using the UVM factory
- Is this really the best way to achieve modularity and 
  interchangableness?
- and to me it seems like this way of reconfiguring testbenches
  is very messy. Do companies actually use it or avoid it?

=================================================================
Week 1 Summary (02.09.2024-06.09.2024)
-----------------------------------------------------------------

This week I started off the project by reading a book on SystemVerilog (SV). I thought it was 
a good idea to understand the exact boundary between what is actually UVM and what is just 
part of SV as a language. 

Most of the language additions over Verilog concern verification and seem very well integrated 
with the language. This is a tough challenge for any non-SV verification framework and opens 
the question to how much should be integrated into a new verification framework and how much 
should be left to be described in SV (Amelia mentioned that people at SiFive are happy with 
writing their SystemVerilog Assertions (SVA) on the SV generated by chisel). Should it only be 
the actual creation and driving of stimulus? Creating something like SVA and even coverage 
collection with the same ease of use as in SV is difficult, because these are described right next 
to the source code they are verifying which also means that internal signals are visible for coverage 
and assertions (how would one reference an internal signal in an SV blackbox when testing in a 
hypothetical Scala framework?).

I read a chapter on UVM in SV which did not reveal much new compared to the PyUVM book that 
I've read in June. I also used chipverify.com as a reference for more complex features of UVM.

In terms of companies which I would like to talk to, I have come up with this list:
- Syosil
- Microchip
- Oticon
- GN
- WS Audiology

I know who to talk to in Syosil and Microchip. Concerning the hearing aid companies, I do not 
have contact persons, but I know that for instance Jens does. I think 4 companies is a good start, 
so I would like to hear if you have any suggestions on who to talk to in which company.

I am figuring out the questions that I would like to ask these companies. Should I ask about very 
specific issues with certain UVM components or should I aim broader and ask about the general 
verification process and how the methodology behind UVM fits their needs? I think the latter is 
more interesting.

This week I will try to get my hands a bit dirty with UVM and verify a use-case. I will also start 
reaching out to the companies. 

How should we proceed in terms of meetings? Should we arrange a weekly slot in the evening?

@Martin, I hope you are enjoying sunny California!

Cheers,
Tjark

=================================================================
Monday, 09.09.2024
-----------------------------------------------------------------

TODO:
  - write mail to Martin and Luca
  - create a simple UVM testbench (eda playground?)
  - read up how register abstraction is actually used

- one basic design choice of UVM is how to handle the concurrency of a testbench
- here TLM with queues is used as a means of communication between TB components
- this is very akin to a "hardware" approach to a testbench with different components
  which are "wired" together
- can this be done in a different maybe more ergonomic way?

- UVM seems like a deep rabbit-hole with way too many features
- things like Easier UVM actually try to restrict the use of UVM to a subset of features
- what is the best balance between maximum customizability and ease of use?


=================================================================
Wednesday, 11.09.2024
-----------------------------------------------------------------

TODO:
  - [x] prepare message to companies describing the project and what I would like to talk about
  - [ ] get uvm running on eda1
  - [X] prepare for meeting with Martin and Luca
  - [ ] get a broad overview of software testing methods
  - [x] create Latex doc for thesis (or should I use typist?)
  - [ ] organize all the downloaded stuff

Martin Feedback:
  - it is only commercial tools implementing the SV features -> that makes it ok to provide the same functionality in a different language if you can avoid commercial tools
  - SVA can't be written into generated SV, but work is ongoing for writing SVA in Chisel
  - software testing methods could be an inspiration for verification
  - is accessing  internal signals in a tb possible?
    - not in SV but through the shell or DPI interface
    - DPI is possible in Verilator
  - I should do a presentation on the project in the chisel meeting monday 18:00

Meeting Agenda:
  - Visit to Berkely
    - When should I come to Berkeley and for how long?
    - What would I do there? Will I get a desk? How is Martins schedule?
  - Coverage:
    - I think it should be possible to do internal coverage, only doing it at the IO seems limiting
    - not only functional coverage but also code coverage (statement, branch, fsm)

Meeting Notes:
  - what should we do?
    - should we try to do something at the methodological level? or just minor improvements over UVM?
  - Luca: interface analysis
  - ask them: what are the weaknesses of UVM?
  - Martin: the small stuff like writing assertions for next cycle
  - SVA will come to chisel, how could this be integrated?


- being able to handle VHDL could be an advantage for a new verification framework
- what is the status of the yosys/GHDL based translation of VHDL to verilog?

- how do we achieve concurrency in the testbench?
- how do we move data around between the structures in the testbench?
  - TLM with queues is used in UVM
  - TLM 2.0 adds timing information to the transactions -> this seems interesting


=================================================================
Thursday, 12.09.2024
-----------------------------------------------------------------

TODO:
  - [ ] get uvm running on eda1
  - [ ] get a broad overview of software testing methods
  - [ ] organize all the downloaded stuff
  - [X] get a JNI working example

- looked at boolector and JNI
- sbt-jni is a plugin to allow for easy integration with scala
- boolector compiled and looked at C api
- it seems difficult to manage the heap allocated boolector objects in scala
- one can save the pointer in scala as a long and then use it in the native code


=================================================================
Friday, 13.09.2024
-----------------------------------------------------------------

# TODO:
  - [ ] get uvm running on eda1
  - [ ] s4noc
  - [ ] get a broad overview of software testing methods
  - [ ] look at stay in Berkeley

- is UVM actcually somehow actor based with its components and channels inbetween?
- would an actual actor based approach be more ergonomic?

- software testing talks about different layers of testing
- unit testing, integration testing, system testing
- how does this map to verification?
- is UVM only a system testing framework?

# Mathias:
- ISO standards for testing (design process v shape process) part of backround research
- hearing aid comapnies will follow this in some form


# Berkeley:
- flights around 800 euros -> 6000 dkk
- accommodation around 13000 dkk
- car around 600 dollars -> 4000 dkk
- sum 23000 dkk

- we should have a base class for a transaction type interface which has put methods 


- we could have multiple archs
- can we automate having multiple archs and testing them all?

- concurrency should be communicated by events
- we need time and events
- actors seem to be a good idea
- expect method for future value?

=================================================================
Week 2 Summary (09.09.2024-13.09.2024)
-----------------------------------------------------------------




=================================================================
Monday, 16.09.2024
-----------------------------------------------------------------

# TODO:
  - [ ] get uvm running on eda1
  - [ ] s4noc
  - [ ] get a broad overview of software testing methods
  - [ ] look at stay in Berkeley
  - [ ] look at ISO standards for testing (V shape process)
  - [ ] look into verilator coverage

- could we create timed assertions from unit tests and let them be used in integration tests? (e.g. capture interface behavior)

- The concepts of UVM have been around for a long time (https://en.wikipedia.org/wiki/Functional_verification#Types)

# What is the unique value of my project?
  - simple things should be simple, complex things should be possible
  - use functional programming features to simplify testbench construction
  - create one framework to support simple unit tests as well as complex integration tests

- focus on communication between components? How can we hide the concurrent nature of the testbench? How can we expose timing and event information at the transactional level?

# proposal

- **should we go for event-based simulation?**

Current testing frameworks such as Cocotb and ChiselTest offer a very simple way of creating testbenches, providing an API to set and get ports and control simulation time progression. When creating more complex testbenches

## problems
- testing frameworks like cocotbor chiseltest provide very basic concurrency abstractions with co-routines and fork-style multi-threading, respectively
- this leaves the structuring of the testbench code to the user, leading to a variety of different approaches and a low chance of code reuse
- UVM provides a more structured approach to testbench construction, but is overly complex, exposing a lot of unnecessary low level details to the user
- UVM does not provide reasonable defaults, which results in large amounts of boilerplate code for simple tests, disencouraging the use of the framework for simple unit testing
- classic UVM testbenches have to be written in SystemVerilog, which is a rather low-level language with limited expressiveness which can impede the efficiency of testbench construction
- ported versions of UVM to other languages like Python (PyUVM) make UVM more accessible by using an easier language, but some of the design decisions which are based on SystemVerilog were not reconsidered
- this results in a framework which does not necessarily take advantage of the features of the new language

## Solutions
- A higher-level language with high expressiveness should be used to create a new verification framework
- The framework should be based on the principles found in the UVM but rethink API decisions on features of the new language
- The framework should provide standard ways of implementing testbenches ranging from simple unit tests to complex system level tests
- The framework should provide the infrastructure for handling communication in complex concurrent testbenches
- The framework should provide reasonable defaults for test components, such that a simple test can be written with minimal boilerplate code

## goals

- consider different concurrency models, which hides the complexity of concurrent programming while being tailored to the domain of testbenches (multi-threading, co-routines, actors, event-driven)
- optimize the communication between components for ease of use (given the concurrency model)
- leverage higher-level abstractions and functional programming for more concise test creation
- facilitate multiple levels of testing (unit, integration, system) with the same framework
- choose reasonable defaults to make simple test creation easy, but allow for customization for more complex tests
- A new verification framework has to support the generation of constrained-random stimuli and coverage collection as well as the possibility to create assertions


# how can we leverage functional programming

```scala
val mon = PcieMonitor(dut.pcie)
val sc = scoreboard(mon.txs) { 
  case (tx, rx) => tx.data == rx.data
}
```

# What bout timing in TLM systems?
- how does TLM2.0 handle the timing? The protocol itself seems overkill for anything

# questions
- How do you check for certain transaction-level guarantees when using TLM1.0, where no timing information is captured in the channels?
- How much are you taking advantage of the reusability aspect of UVM? Are you at a point where testbench construction is accelerated by reusing components?


# actor based programming
  - TTCN-3 (Testing and Test Control Notation version 3) is a strongly typed testing language used in conformance testing of communicating systems.

# concurrency models
- parallel discrete event simulation (PDES)

# Software testing

## data driven testing frameworks
  - Separates the test case data from the executable test script
  - They reduce the cost of adding new tests and changing them when your business rules change. This is done by creating parameters for different scenarios, using data sets that the same code can run against.
  - They help to identify what data is most important for tested behavior. By separating first-class scenario data into parameters, it becomes clear what matters most to the test. This makes it easy to remember how something works when developers need to change it.
  - this seems a lot like what UVM tries to achieve by using sequencers
  - disadvantages: 
    - large code base for testing
    - hard to maintain
    - more documentation
    - more skill needed to write tests

## keyword driven framework
  - capture more complex behvaior in *keywords* to simplify test cases
  - aren't these just functions with more work?
  - allows test case developers to not worry about the implementation details of the test

=================================================================
Wednesday, 18.09.2024
-----------------------------------------------------------------

TODO:
  - [x] get uvm running on eda2 instead
  - [ ] s4noc
  - [ ] get a broad overview of software testing methods
  - [ ] look at stay in Berkeley
  - [ ] look at ISO standards for testing (V shape process)
  - [x] look into verilator coverage
  - [ ] look into TTCN-3
  - [ ] read "verilog and its ancestors"
  - [ ] create a verilator systemc example
  - [x] create verilator cpp example

# Verilator
- we can drive verilated models via cpp or systemc
- systemc seems to have a notion of time
- one can connect multiple verilated sc modules together -> this could be useful for testing multiple duts together without creating a hardware description
- coverage includes (https://veripool.org/guide/latest/simulating.html#user-coverage)
  - functional coverage in the form of assertions
  - line coverage
  - toggle coverage
- randomization seems to work

- one can basically create a shell around a verilated model which could also be used to single step for debugging
  - can we do real time dumping to a file? YES!
  - there could be an interactive mode for debugging


# OSVVM
- OSVVM is a free library of packages providing additional capabilities and utilities for VHDL and verification
- https://github.com/OSVVM/Documentation/blob/main/OSVVM_structured_testbench_framework.pdf
- https://osvvm.github.io/Overview/Osvvm1About.html

- SystemVerilog does not allow variable indexing of interface arrays...
- it does, but only on virtual interface arrays
- normal interface arrays are only allowed to be indexed with variables in generate blocks

=================================================================
Thursday, 19.09.2024
-----------------------------------------------------------------

TODO:
  - [ ] s4noc
  - [ ] get a broad overview of software testing methods
  - [ ] look at stay in Berkeley
  - [ ] look at ISO standards for testing (V shape process)
  - [ ] look into TTCN-3
  - [ ] read "verilog and its ancestors"
  - [ ] create a verilator systemc example

- verilator does allow for delay statements in the verilog code
- the timescale resolution controls what one simulation tick means
- we can control how many simulation ticks per clock cycle we want
- if we skip simulation ticks where an event should have occurred, we get an error -> do we have to evaluate at each tick or is there a way to figure out whether events are pending?

- got s4noc running on eda2 with the first transactions going through the noc using sv interfaces

=================================================================
Friday, 20.09.2024
-----------------------------------------------------------------

TODO:
  - [ ] write down final set of questions for companies
  - [ ] setup agents for s4noc and send first uvm transactions (only drivers)
  - [ ] look at stay in Berkeley
  - [ ] investigate `simPublic` from spinalHDL
  - [ ] verilator multi clock? (https://zipcpu.com/blog/2018/09/06/tbclock.html)

- we should support running multiple tests on the same hardware reducing the need for recompilation

- if we want to collect coverage information, the more performant solution would be to do so in CPP
- this means functional coverage has to be declared before the testbench is compiled



=================================================================
Week 3 Summary (16.09.2024-20.09.2024)
-----------------------------------------------------------------

- project focus:
  - testing frameworks like cocotb, chiseltest and spinalhdl sim provide basic means to interact with the dut
  - but no higher level abstractions to allow for more complex testbenches
    - how do multiple concurrent verification components communicate?
  - UVM provides structured way to do so, but does not scale well with simple tests
  - a new framework should reconsider UVM decisions and tailor API to language features
    - real software language allows for more expressive testbenches
    - functional programming lang features could be leveraged to simplify testbench construction
  - reasoneable defaults should be provided to make simple tests easy to write
  - allow for multiple levels of testing with the same framework going from unit to system level tests
  - the framework should support the generation of constrained-random stimuli and coverage collection as well as the possibility to create assertions

Amelia:
- add simulation operations peek, poke.. as MLIR dialect
- what front-end? of course all front-end *could* profit from this
- how to have arbitrary code interact with the dut?
- common backend to generate sv testbenches

- Timing in TLM systems:
  - how do you ensure when transactions are actually put on the pins?
  - how to ensure simultaneous transactions are actually simultaneous?

- software testing:
  - did not find anything useful yet
  - a lot of it is tailored to web development
    - data driven testing frameworks seem similar to UVM testbenches

- Verilator, C++ and SystemC
  - created cpp driven testbench for verilated model
  - allow for delay annotations
  - we can also connect multiple verilated models together
  - in systemc this is actually supported (bind)


- s4noc uvm testbench


=================================================================
Monday, 23.09.2024
-----------------------------------------------------------------

TODO:
  - [x] scala3 name macro
  - [ ] questions for companies
  - [ ] setup agents for s4noc and send first uvm transactions (only drivers)
  - [ ] look at stay in Berkeley
  - [x] investigate `simPublic` from spinalHDL
  - [x] verilator multi clock? (https://zipcpu.com/blog/2018/09/06/tbclock.html)
  - [x] create simple btor2 crv example


- scala3 macros make capturing the name of the enclosing val easy

- verilator multi clock
  - we can check how long time before each clock has to tick
  - advance the time til then, evaluate the clock and repeat
  - io updates need to be bound to a clock! (this looks like SV interfaces)
  - they should be scheduled at the falling edge

- argument against uvm factory is compile time type checking


## software testing

- Unit testing
  - fixtures provide a mechanism to establish a known state of the uut
  - setup fixtures -> code to create objects, configure settings and prep data
  - teardown fixtures -> code to clean up after the test ensuring no state leaks into other tests
  - parameterized fixtures -> same test for different parameters

- Boundary value testing
  - test the boundaries of the input domain
  - hypothesis framework in python

- Equivalence partitioning
  - divide the input domain into equivalence classes
  - test one value from each class

- QuickCheck
  - property-based testing
  - generate random inputs and check properties
  - can be used for functional verification
  - Scala has ScalaCheck!


### take aways
- fixtures are good because they let us reuse the already running simulation!
- they also make generator parameters first class citizens
- parameterized fixtures seem a little awkward to use (python they are in meta programming) -> can this be done better


## SpinalHDL
- uses swig for interfacing with verilator
- simPublic seems no really to do anything to the generated verilator model

## Thoughts

- The DSL part should be decoupled from the implementation and backend
- This should allow for later optimizations


## CRV
- SMT solvers are actually not good at producing nice distributions, they are deterministic..
- boolector seems to ignore the seed for simple examples
- there is a scala z3 wrapper
- z3 supports incremental solving, so already seen values could be excluded from the next generation

- verilators contrained random solver is under development (crave) https://github.com/agra-uni-bremen/crave

- jacop is still an option

- pyVSC seems to be doing a lot of stuff around pyboolector (what exactly?)

- SMTSampler concerns itself with the distribution of the values
- uses z3 under the hood with some modifications
- https://github.com/RafaelTupynamba/SMTSampler


=================================================================
Wednesday, 25.09.2024
-----------------------------------------------------------------

- graalvm can compile scala to native code
- we can include native libraries in the scala code using JNI and then link them into the native binary
- there is a sbt plugin for graalvm native image


# Meeting
- early chisel had some work to generate a TB from the test code in verilog to be run on the FPGA (so something like firesim)
- crv and coverage are nice to haves, the focus should be on the testbench structure
- so focus on creating standard components, standard communication interfaces and standards for parallelism


=================================================================
Thursday, 26.09.2024
-----------------------------------------------------------------

TODO:
  - [ ] create an API outline for an actor with phases
  - [ ] create an AST for constraints and a DSL to create such an AST, then use brute force for now to find solutions
  - [ ] look at how CRV with jacoP in chiselverify creates different solutions to same problem

- I should combine actors with the phasing model
- each actor has different phases and reactions bound to phases
- this could be completely event driven?
- one runtime to register events and event listeners
- the runtime schedules actors reactions on a thread pool
- queues of UVM are maintained in the background by the runtime -> message queues



- idea: in UVM scoreboards and other analyzers connect to monitors which broadcast their transactions
- why not use an publish/subscribe model? monitors publish on a topic and scoreboards subscribe to the topic

- is the uvm reset phase run in parallel?

- the pre and post phases could be done having a @, during and after modifier on the phase recactions

- GraalVM has a LLVM backend
- with this we could create llvm-IR from scala which could then be used inside circt
- how could we replace calls to peek, poke and so on with circt sim dialect IR instructions?
- could the calls be marked as native and then the argument passing + call code is replaced with one llvm-IR instruction?

# Ingredients

- AST for constraints
- DSL for constraints
- solver backend for constraints

- type system for hardware to create interfaces
- a bundle type for the interface should do
- what kind of hardware types do we need?

- hardware module type with interface
- potential chisel bridge

- coverage for ports


- could we have a unified `Conext` concept for DSL constructs
- a bundle context takes the defined signals and adds them to the record
- a module record would take singal defs and add them to the nets
- a simulation context would do what?

# Constrained Random

- what kind of data types should be supported?
- only hardware data types?


## Enums

- we can access the list of enum variants
- `.productArity` gives the number of contained values
- we can use this to only allow basic enums without nested values

=================================================================
# Friday, 27.09.2024
-----------------------------------------------------------------

TODO:
  - [x] create a project plan outline
  - [ ] setup agents for s4noc and send first uvm transactions (only drivers)
  - [ ] look at stay in Berkeley



# Checklist

## Type System
1. create a simple type system DSL with
  - bit and bitvector (signed and unsigned)
  - vecs
  - bundles
  - enums

## Constraint System
1. create a constraint AST which is associated with bundles
2. create a DSL to create constraints
3. create a solver backend for constraints

## Simulator Interface
1. Define API for controlling simulation
2. Implement runtime for API
3. Choose mode of communication between scala host and simulation
4. Define interface between scala host and simulation
5. Implement interface

## Concurrency Runtime
1. Investigate different models for concurrency
2. Define an API for a unit of concurrency
3. Implement runtime for concurrency management

## Testbench Model
1. Develop a standardized testbench structure
2. Define class system for testbench primitives
3. Implement defaults
4. Implement test API for different levels of testing

## Documentation
1. Write technical background
  - SystemVerilog
    - history
    - hardware description subset
    - OO features
  - constrained random verification
    - SV DSL
    - usage in verification
    - SAT, SMT solvers
    - sampling techniques
  - Coverage
    - Code coverage
      - line
      - branch
      - fsm
    - Functional coverage
      - SV DSL
      - usage in verification
  - Hardware verification
    - simulation based testbenches
    - formal methods
    - higher level abstractions
      - bus functional models
      - [???](https://en.wikipedia.org/wiki/Functional_verification#Types)
    - UVM
      - history
      - components
      - usage
  - Software testing
    - unit testing
    - integration testing
    - system testing
    - data driven testing
    - keyword driven testing
    - boundary value testing
    - equivalence partitioning
    - quickcheck
  - Actor based programming
    - history
    - usage in verification
    - akka
    - TTCN-3
  - Simulators
    - event driven simulators
    - compiled simulators

  2. Write about interviews with companies
    - summaries of interviews
    - insights gained

  2. Designing a new verification framework
    - discuss shortcomings of UVM
    - discuss design choices for new framework
    - showcase pseudo code for new framework


  3. Write about Implementing design
    - discuss language options and jutsify choice
    - explain choices of type system DSL
    - explain choices of constraint system DSL
  
  4. Describe simulator interface and backend implementation

  5. Describe concurrency runtime implementation

  6. Describe testbench model implementation

  7. Write user guide

  8. evaluate the framework with use-cases

  9. Discussion
  
  10. Conclusion


## functions accepting generic scala3 enum companion object

- scala3 enums are expanded to a type declaration + object with enum variant defs
- the object does *not* extend anything, but has some predefined methods
- we can restrict a method to
  - only accept singleton objects
  - use structural typing to check whether a `def values: Array[reflect.Enum]` method exists
- this seems good enough to check that we indeed have received an enum


=================================================================
# Monday, 30.09.2024
-----------------------------------------------------------------

TODO:


- scala offers asynchronous execution on a thread pool using futures
- the api is not as nice as real async/await
- async/await existed for scala2 with some limitations but not for scala3


=================================================================
# Thursday, 03.10.2024
-----------------------------------------------------------------

TODO:
  - [x] create a GCD verilated design with simple interface
  - [x] hook up interface to scala
  - [ ] use a custom verilated context which is destroyed to allow for reruns on same sbt instance


# multi-threaded simulation

- a clock advancing releases all threads that called step for that clock (mechanisms for multi steps, skipping some releases could be added)
- all threads that ran due to the clock event need to signalize when they are done, such that the simulation runtime can do the next upcoming clock tick
- the simulation runtime acts like an operating system, scheduling threads when they should run


- should the only events be clock events? and if so only rising edge events?
- it would be great if we supported both timed and clock driven simulation

- clock.step() positions simulation time just after rising edge of clock, i.e. all register updates have been applied
- time.tick(1 ns) advances simulation time til just after 1 ns has past, i.e. if in 1 ns a clock ticks, all register updates have been applied

- if the runtime can associated release events with threads, then actors are just threads with multiple release events
- here the event would be passed to the thread, such that it knows which reaction to run

- verilator vpi requires a simpublic annotation in the verilog source to expose signals to the vpi interface


=================================================================
# Friday, 04.10.2024
-----------------------------------------------------------------

TODO:
  - [ ] use `gcd->eventsPending()` and `gcd->nextTimeSlot()` in the simulation loop

# Verilator wrapper
- the simulator has setup and teardown methods
- else there is one function which has the following args
  - two arrays providing ids and values of input changes
  - two arrays to deposit the ids and values of output changes

- timing seems a little weird in verilator
- maybe for now, only support own time (don't consider delay statements in verilog)


=================================================================
# Monday, 07.10.2024
-----------------------------------------------------------------

- The main controller thread interacting with the simulation is actually not a thread but whatever thread happens to be the last one to finish for this step
- when a thread finishes it checks if there are any more threads to run and unblocks one of them if there are
- if there aren't simulation ticks to next event controlled by the last thread to finish
- then that last thread releases all threads fitting in the cores and blocks itself until its event occurs unless it was waiting for this event

- chiseltest has some kind of schedule order based on the fork join hierarchy
- why should this be necessary?


- chiseltest has a simcontroller which uses a scheduler

=================================================================
# Tuesday, 08.10.2024
-----------------------------------------------------------------

## TODO:
	- [ ] create a simple scheduler 
  - [ ] handle wide verilator fields
  - [ ] join sim threads before exiting


## Notes
- `scala.DelayedInit` lets you run code before the constructor of a class
- implement `delayedInit(body: => Unit)` in the class to run code


- what we would really have to do to achieve good co-routine like parallelsim would be
  to split actions between clock ticks into small work packages which are submited to a thread pool
- what about control flow around clock ticks? like a while loop which runs until a certain condition is met?
- a compiler pass could probably do this but it would be a lot of work


- project loom is perfect for cooperative multi tasking of driver tasks
- https://www.baeldung.com/java-virtual-thread-vs-thread
- but it is still under development

## Single threaded sim runtime

```
[Time] 99540943
[Sched] switching nested3 -> main
Simulation took 100294 ms
Simulation frequency: 992.4915049753724 ticks/ms
```


- consider doing more in java

- use edu4chip as a medium sized use case

- scott beamer is doing a simulator for firrtl


=================================================================
# Friday, 11.10.2024
-----------------------------------------------------------------

# Time model

- how can we allow a system which both has clock steps and explicit time steps as mechanisms for advancing time?
- in sv @( clocking_block ) waits for the positive edge of the clock
- 

- should we only allow to schedule events for certain point in time?


- we can start only allowing stepping on clocks
- only one clock is allowed to be used in a thread
  - how can we enforce this constraint?

- when a thread reaches a clock step it is blocked until the clock ticks and all side effects had the chance to occur, i.e. the last sim tick before the next posedge of the clock
  - that means it registers the absolute time stamp it wants to be woken up at

- at each tick we have to do the following
  - check if any drive actions are pending and note the closest time tag
  - check if any clock edges are pending and note the closest time tag
  - choose the smaller time tag event
  - advance the simulation to the time tag
  - do the action
  - continue to pop drive and clock events until non exist for the time tag
  - call eval to apply the changes to the model
  - release the thread which was waiting for this time tag
  - 


=================================================================
# Monday, 14.10.2024
-----------------------------------------------------------------

# TODO
  - [x] fix absoulte/relative time issue
  - [x] get multi threadig running with actual model
  - [x] create a cdc example
  - [ ] start finding sources for thesis chapters
  - [ ] look at UVM reference manual and documentation


=================================================================
# Wednesday, 16.10.2024
-----------------------------------------------------------------

# TODO
  - [ ] start finding sources for thesis chapters
  - [ ] look at UVM reference manual and documentation
  - 



# Notes

- ports give access to pins of dut
- interfaces are collection of ports with associated methods and coverage


- phasing model
  - we could extend the phasing model with custom phases
  - actors could register reactions to phase startups (before), execution (during) and shutdown (after)

```scala
class MyAgent(seq: Sequence) extends Agent {

  before(Reset) {
    // do something
  }

  during(Reset) {
    // do something
  }

  after(Reset) {
    // do something
  }

  during(Run) {
    react(seq.channel) {

    }
  }

}
```


# Notes UVM guide

> Common transaction-level abstractions today include: cycle-accurate, approximately-timed, loosely-timed, untimed, and token-level.


- remember Odesky: language should now reflect mechanism but intent
- the whole port export shinanigans reflects mechanism

- the uvm factory and config db allow configuration penetrating multiple levels in the class hierarchy without any *explicit* parameters
- configurability should be thought into the class *anyways* so why not make it explicit through formal parameters?

# Ideas for UVM like types

```scala
trait Transaction {

}

trait Producer[T <: Transaction] {
  def put(t: T): Unit
}

trait Consumer[T <: Transaction] {
  def get: T
}


```

=================================================================
# Thursday, 17.10.2024
-----------------------------------------------------------------

- how can we have the context be passed down through all levels of hierarchy such that a struct in a struct in a struct knows that it is part of a port declaration?


```scala

class MyBundle extends Bundle {
  val a = UInt(8.W)
  val b = new Bundle {
    val c = UInt(8.W)
  }
}

class MyInterface extends Interface {
  val a = Input(UInt(8.W))
  val b = Output(UInt(8.W))
  val c = new Bundle {
    val d = Input(UInt(8.W))
  }
}


```

- should we keep the type information of directionality?


=================================================================
# Friday, 18.10.2024
-----------------------------------------------------------------


# TODO
  - [ ] ordering errors for pokes and peeks


# Ordering
- should we also have a separate region `Monitor` like in chiseltest
- or should we just say that all pokes are applied before peeks?
- chiseltest uses thread priorities to enforce ordering


=================================================================
# Tuesday, 29.10.2024
-----------------------------------------------------------------

# CRV
- kevin laefuer actually was part of some work on sampling of smt solvers
- https://github.com/RafaelTupynamba/quicksampler?tab=readme-ov-file
- https://github.com/RafaelTupynamba/SMTSampler
- https://github.com/RafaelTupynamba/GuidedSampler


# Notes

- we should provide a simple global interface to a config db
- config db seems to be only used in hierarchical cases, so is Jacobs argument about the sender not needing to have a handle to the receiver really valid?
- the hierarchy is static, so a parent would HAVE a handle to any child or sub-child

- the uvm factory allows for true runtime overrides via commandline, i.e. no recompilation needed
- is this really a good argument? we only have to recompile the testbench, not the dut


=================================================================
# Wednesday, 30.10.2024
-----------------------------------------------------------------

- There are three distinct parts of a UVM testbench
  - the test
  - the environment
  - the sequences 



# configuration
- could we "propagate" configuration parameters in a simple way through the design hierarchy?


# coordinating end of test
- in uvm we have objections
- jacob talked about consensus in OVM or VMM
- a phase could have a consensus object where components can register their agreement to end the phase


=================================================================
# Friday, 01.11.2024
-----------------------------------------------------------------

# TODO
  - [ ] create wide peeks and pokes for verilator
  - [ ] decide on how to share simulation context (shared variable vs. givens)

- ioc (inversion of control)
- use only traits, not generics! we are only interested in what it is able to do, not the specific type


=================================================================
# Tuesday, 05.11.2024
-----------------------------------------------------------------

# TODO

- [x] wide verilator pokes and peeks


=================================================================
# Wednesday, 06.11.2024
-----------------------------------------------------------------

# Sequences & Sequencer 
- an iterator is not good enough to model sequences since there is Feedback
- writing sequences as a kind of state machine is maybe also awkward


```scala

class MySequence extends Sequence[MyItem] {

  def body = {
    // do something
    yield(MyItem())

    // do something
    yield(MyItem())
  }
}

@main def test() = {
  val seq = MySequence()
  prntln(seq.next())

  for (item <- seq) {
    println(item)
  }
}

```


# Simulation
- we could use channels to the 



=================================================================
# Thursday, 07.11.2024
-----------------------------------------------------------------


- the scheduler has to be aware of:
  - all threads that may interact with the hardware
    - could be handled in the fork call
  - it can then wait for all threads to enter a waiting state.


=================================================================
# Friday, 08.11.2024
-----------------------------------------------------------------


# Sequences

- there should be two types of sequences:
  1. sequences with feedback
  2. sequences without feedback (i.e. *dumb* sequences)
- the dumb sequences should be obtainable from any scala collection
  - they probably all implement the iterator trait
  - we could provide a conversion from an iterator to a sequence

- the sequences with feedback are step by step recepies where the sequence writer obtains some feedback for each applied item
- here we need to use bi-directional channels and run the sequence in another thread


- to the driver it should look all the same whether it is a sequence or a dumb sequence


=================================================================
# Friday, 22.11.2024

# Forks

- when forks are waiting for other forks, they need to register this with the scheduler


=================================================================
# Monday, 25.11.2024
-----------------------------------------------------------------

- use Comp() wrapper to get around too many annoying parameter for user component classes
- comp handles naming (also enclosing term) and passes parent, adds to children and so on

- when constructor IoC is used, how can parameters be decided at a lower level?
- is this actually necessary?
- 


- can active vs. passive agent be contructed by mixing in?
```scala
val myAgent = new MyAgent with Active
```


- how should phasing be staged, i.e. when should the current phase exit and the next phase enter?

=================================================================
# Monday 2.12.2024
-----------------------------------------------------------------

# TODO
- [ ] decide how to deal with monitoring threads (they should read after all drives)


- Likely, marking a thread as sleeping or awake should be acked by the scheduler?

- there seems to be an issue with the current channels, where the async backend is too slow 
  to release the waiting thread before the scheduler proceeds time


=================================================================
# Tuesday 3.12.2024
-----------------------------------------------------------------

- a scheduler for the simulation framework has to be concerned with the following things:
  - progression of time
  - release of threads at the right time
  - threads being blocked due to other reasons than waiting for time
    - threads waiting for other threads to finish (join)
    - threads waiting to send/receive a value on a channel


=================================================================
# Wednesday 4.12.2024
-----------------------------------------------------------------

# TODO
- [ ] create the error and warning summary at the end of a test


=================================================================
# Friday 6.12.2024
-----------------------------------------------------------------

# TODO:
- [ ] register abstraction layer
- [ ] try out the public annotation list as external file like in patmos 